풀리퀘스트1
#새로운 사용자의 수정이 이루어졌습니다.
이동혁 컴퓨터전자시스템공학부 201902482 

파이썬

한줄 주석
#
전체 주석
"""을 앞 뒤로

지수형 표기
1.1e3=1.1*10^3

정수(intEGER)표기 : 인터프리터로 무한히 계산 가능
실수(float) : 소수부분을 이진수로 표기할때 문제가 발생할 수 있다.(변환시 무한소수가 되면 제한된 양만
계산할 수 있는cpu는 십진수기준 유효 15자리까지(0이 아닌 수가 나왔을 때부터)만 계산하고 그 밑은 잘린다.)

무한대 : float('inf')

정수로변환 int(실수) : 소수 버림
반올림표기 : print(round(1.4999)) : 1.4999의 반올림 값을 인쇄하라

모듈 붙이기 import math(math모듈 기능을 전부사용)=from math import*

from math import e, pi(math모듈 중 e, pi만 사용
이 때는 기능들이 math모듈에 있는 것이 자명하여math.을 안붙여도 된다.)
아이들에서 실행시킬때마다 초기화되므로 모듈을 넣어줘야 한다.
올림 math.ceil(실수)
내림 math.floor(실수)

0b숫자 : 숫자가 2진수임
0o숫자 : 숫자가 8진수임
0x숫자 : 숫자가 16진수임

복소수
1.2(실수부)+3.4j(허수부)
complex(1.2, 3.4) or 1.2+3.4j 로 표기

삼각함수와 복소수 모듈
import cmath
사인함수 : cmath.sin(복소수까지 가능)          math.radians(도 단위 각도)
근호 : cmath.sqrt(복소수까지 가능)
파이 : pi

고정소수점 : cpu미제공 파이썬제공하는 decimal모듈 사용(float 오차없앨 수 있으나 매우느리다.)

// : 몫을 나타냄
% : 나머지를 나타냄(요일계산 등에 활용가능)

num//=10
num=num//10     둘은 같은 의미

'숫자' : 단순한 숫자가 아닌 문자열(숫자가 나란히 있다)이다.
'문자'+'문자' : 나란히 쓰기

연산자 우선순위
(단항 : -2 등) > (**) > (%//)=(*/) > (+-)

**는 뒤부터 연산임을 주의 : 2**3**4=2^81


코딩테스트
프로그램 실행 후 사용자의 입력을 통해서 출력 값이 나오도록 코딩하는 것이 필요
a=int(input())
b=int(input())
print(a+b)
실행후
3,4입력하여 3+4를 도출하도록 하자

확장 사용
c, d=3, 4
e, f=f, e(변수를 바꿔서 사용할 때 이용하고 많이 쓰인다고 함)

문자를 원하는 자료형으로 변환
age=int(input(your age?))

메모리 관점에서
소수점 이하 3자리까지 가져라(메모리가 가지고 있는 값을 소수점 3자리까지 갖게함 손실o)
소수점 이하 3자리까지 표시하라(메모리가 원래값을 가지고 있지만 화면표시할 때만 3자리까지 손실x)


리스트
다수의 데이터 모음(각 데이터의 자료형은 자유롭다)
[0번데이터,1번데이터,...]
리스트의 정보 추출
1. 인덱스 a[숫자] : 해당번째 데이터(원소)를 가져옴
해당번째 데이터에 리스트가 있다면 a[숫자][숫자]로 리스트안의 리스트의 뒷숫자번째 데이터를 가져옴
a[숫자][슬라이싱] : 리스트안의 리스트를 슬라이싱하여 가져옴
2. 슬라이싱 a[숫자:숫자] : 앞숫자~뒷숫자전까지의 데이터를 리스트로 하여 가져옴
음수를 입력하면 가장뒤를 -1로 설정
3. ::숫자 : 처음부터 끝까지 나열하는데 숫자대로 징검다리로 출력 양수는 정방향, 음수는 역방향

리스트의 연산
덧셈 : 뒤에 붙여서 나열된다 [1,2]+[a,b,c]=[1,2,a,b,c]
곱셈 : 같은 리스트를 반복나열시킨다 [1,2]*2=[1,2,1,2]
값변경 : 리스트가 이미 있는 상태에서 a[2]='자료'를 하면 2번데이터를 '자료'(원소)로 바꾼다
자료가 리스트의 형태를 띄고 있다면 리스트를 원소로 하는 형태이고 리스트 안의 리스트를
가져오는 방식을 이용할 수 있다.
a[2:3]='자료'는 2번데이터 자리의 원래 값을 지우고 새로운 데이터(원소)를 넣는데, 자료가 리스트라면
한번에 여러 원소가 추가될 수 있다.(리스트에 데이터를 추가하는 하나의 방법)

원소의 추가/제거
a.append() : 리스트 끝에 원소하나 추가(리스트가 정의되지 않으면 사용 불가능)
a.insert(숫자,'자료') : 숫자번데이터에 '자료'를 끼워넣고 나머지는 뒤로 밀린다.
a.remove('자료') : 리스트에서 처음나오는 그 자료를 제거한다.

a.sort() : 작은수부터 재배치
a.reverse() : 원래의 반대방향으로 배치
a.sort(reverse=True) : 큰수부터 재배치(True는 그 기능을 켜라 라는 뜻)

score[0].append(total) : 0번데이터리스트의 총합을 리스트 맨 뒤에 추가

len(a) : 데이터 갯수(length) 출력
a.index('자료') : '자료'가 몇번째에 있는지 출력(가장 앞쪽번호의 데이터번호만 출력됨)
a.index('자료',숫자1,숫자2) : '자료'가 숫자1~숫자2번 데이터 사이에 있는지 확인(같은 자료가 여러번 있을 수 있으므로)

a=[1,2,2,3]
b=a.index(2)             2가 몇번째 데이터에 있는가
c=a.index(2,b+1,3=len(a)-1)     그외에 몇번째에 2가 또 있는가(d= c+1로 반복사용)
없는 자료를 찾으려하면 에러가 나서 그 뒤의 문장을 실행하지 못한다.


툴의 괄호와 점의 차이 : 점은 특정 자료형에만 사용가능한 툴(append), 괄호는 다른 자료형에도 가능(int,len)

자료 끄집어내기
a.pop(데이터번호) : 해당번호 데이터를 가져오고 그 데이터를 삭제

자료 개수세기
a.count('자료') : 자료가 리스트안에 몇개 있는지 확인

제어문
if문 : 조건을 만족하면 실행
while문 : 특정조건을 만족하면 만족되지 않을 때까지 반복실행
for문 : 일정횟수(5번,리스트개수만큼,...)만 반복실행

if문 사용법
if 조건:(:를 끝에 붙여줘야함)
들여쓰기(여러문장이면 다 들여쓰기해야함) 문장1(조건 만족시 실행할 문장으로 여러문장도 가능)
else:
들여쓰기(위의 덩어리와 같은 글자수로 들여쓸필요는 없음) 문장1(조건이 만족되지 않으면 실행)

성립할때 pass를 입력하면 else일때 문장출력으로 활용가능

구간을 나눠서 경우를 따질때
if:
else:
	if:(첫번째 if는 이미 불만족 두번째 if만족하는지 확인)
	else:

if:
elif: 
else: 로도 표기할 수 있다.

조건만족시 출력문장이 한문장일때 같은줄에 써도 된다.

비교연산자(조건문을 만들때 이용)
== : 좌우변이 같다
>< : 대소비교
<= : 이상 이하
!= : 다르다

*if문을 이용하여 비밀번호 input이 성립하면 '어서오세요' 출력 등 이용가능
또는 변수에 저장된 값을 변경하여 계좌처럼 저장고의 기능도 가능

논리연산자(조건문을 여러개 나열하여 만든 새로운 조건문)
if x or y:
if x and y:
if not x:

비교연산자를 먼저 계산하고 논리연산자를 나중에 계산

a>자료>b의 경우 a>자료 and 자료>b:로 나눠서 사용

조건문에 변수만 표기할 수도 있는데
변수값이 0이면 false, 0이 아니면 true로 취급
if not 변수:(변수가 0일때 true 취급)

in 연산자
변수 in 리스트(리스트안에 변수가 있는지)

if 2 in list:(2가 리스안에 있으면)
if list.count(2)>0:(2가 리스트안에 있는 개수가 0개 이상이면)

if를 이용한 연산자
x=a*2 if>5 else a/2
(a>5면 a*2, 아니면 a/2)

print[리스트][인덱스]
인덱스에 조건을 넣을 수 있는데 참,거짓에 따라 1,0을 출력한다

while문 사용법
while 조건:
문장1(조건에 만족하면 문장1을 계속 실행)

메뉴표시법
변수="""
1.~~~
2.~~~~
3.quit
숫자를 입력하세요"""(문자열을 줄바꿈 포함하여 작성하는 법)

3이 아니라면 메뉴기능을 수행하고 3이라면 while문 탈출
다른 탈출법
while을 만족하면서 내부의 if에 만족할때 break 입력시 while문 탈출

while반복 응용
while 만족시 출력하다가 continue를 만나면 while부분부터 다시 시작

자료형-튜플
>>자료저장의 기능
>>모양 : t1=(a,b,c),  t2=(a,) (하나일때는 뒤에 ,를 붙인다)
   x,y=1,2의 경우 변수에 대입을 한줄로 처리하는 것이고 튜플이 아니다
>>튜플 안의 값을 바꿀 수 없다(사용자의 실수로 값이 변하는 것을 방지하는 목적)
   윷놀이=(도,개,걸,윷,모)처럼 고정됐을 때 사용 권장
>>튜플이 다른 튜플의 원소가 될 수 있다.(리스트도 마찬가지)

>>>인덱싱 : t1[0]
>>>슬라이싱 : t1[1:] (1번~마지막번 원소)
>>>튜플더하기 : t3=t1+t2
>>>튜플곱하기 : t3=t2*3
     튜플을 피연산자로 하여 새로운 튜플을 만드는 형태


딕셔너리
>>여러개의 데이터를 저장
>>원소의 순서가 의미없고 key와 value의 자료형은 자유
>>key와 value를 대응하여으로 입력
>> 예시
key       |  value
류현진   |  야구
사과      |  apple
>>모양 : dic={'key1':'value1','key2':'value2'}
>>두개의 리스트를 사용하여 딕셔너리 기능을 할 수 있으나 순서를 고려하는 연산이라 오래 걸린다
>>동일한 key를 가진 value들이 있을때(ex 동명이인) 먼저 넣은 key-value만 출력할 수 있다
>>key는 변하지 않을 값으로 설정해야한다(ex 이름 주민번호) key를 바꾸는 것은 새로운 데이터를 넣는것

a={1:'a'}일때
>>>추가 : a[2]='b' (딕셔너리a에 2:b 추가)
>>>삭제 : del a[1] (1:'a' 삭제)
>>>변경 : a[2]='c' (2의 value가 b에서 c로 변경)
>>>출력 : print(dic[1])=a
>>>key만 추출 : a.keys() (dict_keys라는 객채생성) or list(a.keys()) (key만 리스트로 생성)
>>>value만 추출 : a.values() (dict_values라는 객채생성) or list(a.values()) (key만 리스트로 생성)
>>>딕셔너리 전체 출력 : for i in list(a.keys()):
			print(i,a[1])
>>>비우기 : a.clear()
>>>다른 출력법 : print(a.get(1))=a (딕셔너리에 없는 key를 입력하면 none 을 출력)
>>>존재여부확인 : 1 in a (1이라는 key가 a에 있는지 확인 True False의 결과물로 나옴)


집합자료형
>>set 자료형
>>모양 : a={1,2,3}
>>원소 순서,중복 무의미 (순서가 없으므로 인덱싱, for문도 불가능)
>>인덱싱하려면 s1=list(s1)

>>>교집합 : s1&s2 또는 s1.intersection(s2)
>>>합집합 : s1|s2 또는 s1.union(s2)
>>>차집합 : s1-s2 또는 s1.difference(s2)
>>>원소하나추가 : s1.add(a)
>>>원소여러개추가 : s1.update([a,b,c])
>>>원소제거 : s1.remove(a)


문자열
>>순서있음
>>a="""a
b
c""" (줄바꿈도 대입한 것)
>>문자열은 일부내용만 바꿀 수 없다(틀린철자 고치기 불가능)
>>a.replace('ll','l1') (a=hello > hel1o)

>>>더하기 : a='hello', b='world'   a+b=hello world (print('hello'+'world'))
>>>곱하기 : a*2=hellohello
>>>인덱싱 : a[2]=l (2번자리 데이터를 인덱싱)
>>>슬라이싱 : a[:3]=hel (0번에서 3번자리 앞까지 슬라이싱) (날짜날씨 문자열를 슬라이싱)


이스케이프코드
\n : 줄바꿈
\t : tab
\특수문자(\'") "\"hello\""


내용 일부 변경가능성
가능 : 리스트, 딕셔너리, 집합, 바이트배열
불가능 : 문자열, 튜플, 숫자


문자열 포매팅
%d : 정수를 문자열 사이에 넣을 때
%s : 문자열을 문자열 사이에 넣을 때
%f : 실수를 문자열 사이에 넣을 때
%% : %출력
'%0.3f' % 3.141592 (3.141592에서 반올림하여 소수점 셋째자리까지 표기)
>>>정렬 : '%10s' % hi (10칸 오른쪽 정렬 문자열hi 출력) (숫자라면 자릿수 위치 맞추기를 목적으로)
>>>word="hello %d world" num=2 print(word % num)
      hello 2 world로 출력 (값 여러개 넣을 때 %(num1,num2))
>>>개수세기 : a.count('bb') (bb가 문자열에서 몇개있나?)
>>>순서찾기 : a.find('b') 또는 a.index('b') (b가 문자열에서 몇번째 순서에 있나?)
>>>대소문자로변경 : b=a.upper() c=a.lower() (각각 문자열 전체를 대문자 소문자로 변경 a를 바꾸는건아님)
>>>공백제거 : a.lstrip() a.rstrip() a.strip (" 문자열 "의 왼쪽끝 오른쪽끝 양쪽끝 제거)
>>>쪼개기 : a.split(',') (문자열이 12,345,678일때 ,를 기준으로 문자열을 쪼갠다'12','345','678')


모르겠어요
a="i am tom and you are jane"
b=""
wordcount=0
for i in a:
	if i==' ':
		print(b)
		wordcount+=1
		b=""
	else:
		b+=1
else:
	print(b)
	wordcount+=1

print(wordcount)

같은 출력 간결해진 코드
a="i am tom and you are jane"
wordcount=0
b=a.split(' ')
for i in b:
	print(i)
print(len(b))


함수
도구를 만드는 것
def functionname (x) :	#x는 외부로 공급받는 데이터(매개변수)
	y=f(x)
	return y		#함수 실행이후의 결과값을 y로 설정, return은 함수의 끝을 의미한다.
>>결과를 돌려주지 않는 함수도 있다.(print같은 함수는 return없음)
>>functionname()은 입력값이 필요없는 함수일 경우이다.
>>실행도중 함수가 나오면 def줄로 돌아가서 함수를 실행하고 그 이후 다음줄로 실행된다.
>>return a,b 즉 여러개일때 (a,b) 튜플형태로 묶어서 반환된다.(return은 0개나 1개만 가능)
>>c,d=function(a,b) (return이 e,f일 경우) c=e, d=f(c와 d를 튜플로 묶어준 것을 생략한 것)
>>매개변수 입력을 못 받았을 때, (x=person) 이런식으로 default 값을 설정하여 보완가능
>>함수 내부에서만 유효한 변수를 '지역변수'라고 하는데 함수실행이 끝나면 없는 값이 된다.
>>전역변수와 지역변수의 이름은 같을 수 있으나 완전히 다른 변수이다.
>>함수 안에 전역변수를 사용하려면 global x 선언을 해야한다.


필기시험에서 나오는 것
프로그램의 결과는? 오류여부? 오류메시지원인? 간단한프로그래밍
실기시험
10~20분이내에 만들 수 있는 수준


파일
print는 기본적으로 줄바꿈이 있음
>중복제거를 위해 end = ''이용
파일의 전체 행수를 모르지만 전체를 읽기위한 방법(for문을 반드시 사용할 필요는 없다.)
>while True, 다음줄이 공백이면 break
sum += line print(sum)
>문자열의 합으로 나타난다.(더할 것이라면 int(line)으로 이용)
while True:
  line = f.readline()
  if not line:
    break
  print(line)
f.close()

csv파일 이용법
line = csv.readline()으로 한줄을 가져오고
line = line[:-1]로 줄바꿈문자를 없애준다.(if v[0]=='\n,일때 바꾼다는 알고리즘으로)
line.split(',')으로 잘라서 이용가능

총점을 나타내는 방법
s = line.split(',')
s.append(int(s[1])+int(s[2])+int(s[3]))    #while문이나 for문으로 더하면 좋을듯


예외처리
try : 
    실행문
except TypeError:(오류가 났을때)
    실행문
else(정상적인 경우)
    실행문
finally(항상실행)
    실행문
> 오류가 나기 쉬운 부분만 좁게 try except문을 사용하는 것이 좋다.
TypeError : 정수형 + 문자열 처럼 더할 수 없는 경우
ZeroDivisionError : 0으로 나눌때 생기는 오류
IOError : 파일 관련된 모든 오류 포함

format(err) : 에러의 종류를 return
traceback.print_exec() == printf(format(err))

잘못입력했을때 다시 입력받게 하는 방법(없는 파일 입력해도 정지되지 않게끔)
>>while문안에 try : open하고 except: continue
반복문 깨는 다른 방법 : repeat = True 하고 깨고 싶을때 repeat = False 입력

외부모듈/내 모듈(#name.py)
함수를 입력해놓은 py파일을 저장(새로 작성하는 프로그램과 같은 위치에 저장)
import my_module
모듈 마지막줄 (모듈을 단독실행할 경우 import할 경우 무시됨)
if __name__ === "__main__" : (언더바사이에 넣는 변수는 시스템내부변수)
  import sys
  fib(int(sys.argv[1]))


객체지향(데이터와 함수를 묶어서 생각)
객체(어떤 값, 어떤 자료형인)와 매서드(특정 자료형, 객체에 사용가능한 함수)
int object has no attribute split(int객체가 split매서드, 속성이 없다)
a = "hello" (a는 hello라는 문자열 객체를 가리키는 것이다.)
>클래스 : 동일하게 동작하는 객체들을 만들 때 필요한 틀(데이터들어갈공간과 동작)
>클래스(자료형으로 볼 수 있다.)>객체 순으로 생성 (과일>사과)
>클래스는 개념적, 객체는 실질적

속성 : 어떤 데이터의 특성이나 값
매서드 : 특정객체내에서 행동하는 함수(모든 함수가 특정객체에 포함되는 것은 아니다.)
객체.매서드() (a.count())

클래스 만들기
여러개의 계산기 만들기
class Calculator:
  def __init__(self):		#클래스안의 메서드1(속성의 이름이 result라는 뜻)
    self.result = 0
  def adder(,self, num):	#클래스안의 메서드2
    self.result = self.result + num:
    return self.result		#클래스를 정의

cal1 = Calculator() #cal1과 cal2가 Calculator클래스를 가진 객체임을 선언
cal2 = Calculator()

cal1.adder(3)	#cal1에 3더하기

클래스 생성에 관하여
class Calculator:		#모든 메서드는 self를 가진다.
  def __init__(self):		#self는 메서드의 매개변수(result가 속성변수임)
    self.result = 0		#객체를 만들기 위한 생성자(객체 생성시 자동호출되는 메서드)
			#속성변수를 초기화하기 위한 목적(식에서는 0으로 초기화)


속성을 저장하기 위한 변수의 형성 (변수명 = 클래스())
객체.속성변수 = "~~" (속성변수에 특정값을 대입하는 방법)
객체.메서드() (객체에 메서드 실행)

클래스의 상속
class SuperCalculator(Calculator):
  def ~~(추가시킬 매서드)
>단계적 상속받는 것이 추가확장시 어느 클래스에서 가져오는 것이 좋은지 선택 가능

def __str__(self):
  return str(self.size)
속성변수가 가리키는 값 출력

s = "hello"
t = "hello"
s와t가 동일한 객체하나를 가리킨다.

속성변수 = 클래스(속성1, 속성2,...)


외부모듈
pandas
numpy(데이터와 수치분석 모듈)



실강
-
list는 자료형 상관없이 편한 이용/느린 속도
numpy에서는 숫자형만 이용/빠른속도
web개발			#자바로 하는 경우가 더 많다.
인공지능(딥러닝/빅데이터)	#많은 수의 데이터를 이용하는 프로그램
>파이썬은 기본적으로 cpu코어중 하나만 사용하는데,
numpy는 모든 코어를 이용하게 한다.
>numpy는 빠른 리스트 정도로 생각할 수 있고, 많은 데이터를 이용하는 것은
여러 함수들을 이용하여 실현한다.
자료형은 단순히 int float가 아닌 CPU가 제공하는 자료형을 이용한다.(속도 증가)



























